<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>HTTP</title>
	<link rel="stylesheet" href="style.css">
</head>

<body>
	<h1>Homework HTTP</h1>
	<h2>Task 1</h2>
	<ol>
		<li>Facebook</li>
		<img src="img/facebook.png" alt="facebook" class="task1">
		<ol>
			<li><strong>Cache-Control- </strong>Указывает директивы для запросов и ответов.</li>
			<li><strong>content-lenght- </strong>длина контента</li>
			<li><strong>content-type- </strong>тип контента, кодировка</li>
			<li><strong>Expires- </strong>Дата / время, после которого ответ считается устаревшим.</li>
			<li><strong>location- </strong> Указывает URL-адрес для перенаправления страницы.</li>
			<li><strong>status-301 </strong> Перемещён на постоянной основе</li>
			<li><strong>Strict-Transport-Security (HSTS)- </strong> Принудительная связь с использованием HTTPS вместо HTTP.</li>
			<li><strong>vary-Transport-Security (HSTS)- </strong> Определяет, как сопоставить заголовки будущих запросов, чтобы решить, можно ли использовать кэшированный ответ, а не запрашивать новый с исходного сервера.</li>
		</ol>
		<li>Google</li>
		<img src="img/google.png" alt="google" class="task1">
		<ol>
			<li><strong>Alt-Svc- </strong> Используется для перечисления альтернативных способов доступа к этой услуге.</li>
			<li><strong>Content-Encoding - </strong> Заголовок объекта используется для сжатия медиа-типа. Когда оно присутствует, его значение указывает, какие кодировки были применены к телу объекта. Это позволяет клиенту знать, как декодировать, чтобы получить медиа-тип, на который ссылается заголовок Content-Type.</li>
			<li><strong>Server- </strong> Contains information about the software used by the origin server to handle the request.</li>
		</ol>
		<li>frontend-materials.cursor.education</li>
		<img src="img/cursor.png" alt="frontend-materials.cursor.education" class="task1">
		<ol>
			<li><strong>Via- </strong> Добавляются прокси, как прямой, так и обратный прокси, и могут появляться в заголовках запросов и заголовках ответов.</li>
			<li><strong>Etag- </strong> Это валидатор, уникальная строка, идентифицирующая версию ресурса. Условные запросы, использующие If-Match и If-None-Match, используют это значение для изменения поведения запроса.</li>
		</ol>
		<li>Duolingo</li>
		<img src="img/duolingo.png" alt="Duolingo" class="task1">
		<ol>
			<li><strong>Pragma- </strong> Специфичный для реализации заголовок, который может иметь различные эффекты в любом месте цепочки запрос-ответ. Используется для обратной совместимости с кешами HTTP / 1.0, где заголовок Cache-Control еще не присутствует.</li>
			<li><strong>Set-Cookie- </strong> Отправить куки с сервера на пользовательский агент.</li>
		</ol>
		<li>show-english.com</li>
		<img src="img/show-english.png" alt="show-english.com" class="task1">
		<ol>
			<li><strong>X-Frame-Options (XFO)- </strong> Указывает, нужно ли браузеру отображать страницу в frame, iframe, embed или object.</li>
			<li><strong>X-Powered-By- </strong> Может быть установлен средой хостинга или другими средами и содержит информацию о них, не предоставляя никакой полезности приложению или его посетителям. Снимите этот заголовок, чтобы избежать потенциальных уязвимостей.</li>
		</ol>
	</ol>
	<h2>Task 2</h2>
	<article>
		<h3>Поддержка прокси и поле хоста:</h3>

		HTTP 1.1 имеет требуемый заголовок узла по спецификации. HTTP 1.0 официально не требует заголовка Host, но не помешает добавить его, и многие приложения (прокси) ожидают увидеть заголовок Host независимо от версии протокола.

		<h3>Стойкие соединения:</h3>

		HTTP 1.1 также позволяет иметь постоянные соединения, что означает, что вы можете иметь более одного запроса/ответа на одно и то же HTTP-соединение. В HTTP 1.0 вам нужно было открыть новое соединение для каждой пары "запрос/ответ". И после каждого ответа соединение будет закрыто. Это приводит к некоторым большим проблемам с эффективностью из-за TCP Slow Start.

		<h3>Метод OPTIONS:</h3>


		HTTP/1.1 вводит метод OPTIONS. HTTP-клиент может использовать этот метод для определения возможностей HTTP-сервера. Он в основном используется для совместного использования ресурсов Cross Origin в веб-приложениях.

		<h3>Кэширование:</h3>

		HTTP 1.0 поддерживал кэширование через заголовок: If-Modified-Since. HTTP 1.1 расширяет поддержку кеширования, используя что-то, называемое тегом сущности. Если 2 ресурса одинаковы, то они будут иметь те же теги сущностей. HTTP 1.1 также добавляет условные заголовки If-Unmodified-Since, If-Match, If-None-Match.

		<h3>Основное различие методов GET и POST состоит в способе передачи данных веб-формы обрабатывающему скрипту, а именно:</h3>

		<p>Метод GET отправляет скрипту всю собранную информацию формы как часть URL: http://www.komtet.ru/script.php?<strong>login=admin&name=komtet</strong> Метод POST передает данные таким образом, что пользователь сайта уже не видит передаваемые скрипту данные: http://www.komtet.ru/script.php
		</p>

	</article>
	<h2>Task 4</h2>
	<img src="img/Task4.png" alt="" class="task1">

	<ol>
		<li>Date →Fri, 14 Jun 2019 20:49:48 GMT (дата запиту)</li>
		<li>Expires →-1</li>
		<li>Cache-Control →private, max-age=0</li>
		<li>Content-Type →text/html; charset=ISO-8859-1</li>
		<li>Content-Encoding →gzip</li>
		<li>Server →gws</li>
		<li>Content-Length →5536</li>
		<li>X-XSS-Protection →0</li>
		<li>X-Frame-Options →SAMEORIGIN</li>
		<li>Set-Cookie →1P_JAR=2019-06-14-20; expires=Sun, 14-Jul-2019 20:49:48 GMT; path=/; domain=.google.com</li>
	</ol>
	<p>
		<strong>Cache-Control</strong> используется для задания инструкций кэширования как для запросов, так и для ответов. Инструкции кэширования однонаправленные: заданная инструкция в запросе не подразумевает, что такая же инструкция будет указана в ответе</p>
	<p>В ответах сервера заголовок
		<strong>Content-Type</strong> сообщает клиенту, какой будет тип передаваемого контента. </p>
	<p>Заголовок объекта <strong>Content-Encoding</strong> используется для сжатия медиа-типа. Когда оно присутствует, его значение указывает, какие кодировки были применены к телу объекта. Это позволяет клиенту знать, как декодировать, чтобы получить медиа-тип, на который ссылается заголовок Content-Type.</p>
	<p>Заголовок ответа <strong>HTTP X-XSS-Protection</strong> это особенность Internet Explorer, Chrome и Safari, которая останавливает загрузку страниц при обнаружении (XSS) атаки. Хотя эти меры защиты не требуются в большинстве случаев для современных браузеров, когда сайты внедряют сильную политику безопасности контента Content-Security-Policy, которая отключает использование встроенного JavaScript ('unsafe-inline'), они могут обеспечить защиту для пользователей, использующих устаревшие версии браузеров, не поддерживающих CSP.</p>
	<p>X-XSS-Protection Атака XSS (межсайтовый скриптинг) это тип атаки, при котором вредоносный код может быть внедрён в атакуемую страницу. Например вот так: Такой тип атаки легко обнаружить и браузер вполне может с этим справиться: если в исходном коде содержится часть запроса, то это может оказаться угрозой. И заголовок <strong>X-XSS-Protection</strong> управляет этим поведением браузера. Принимаемые значения: 0 фильтр выключен</p>
	<p>HTTP-заголовок ответа <strong>Set-Cookie</strong> используется для отправки файлов cookie с сервера пользовательскому агенту.
	</p>
	<h2>Task 5</h2>
	<img src="img/Task5.png" alt="" class='task1'>
	<h2>differences between HEAD and GET methods</h2>
	<p>Метод HEAD идентичен GET, за исключением того, что сервер НЕ ДОЛЖЕН возвращать в ответе тело сообщения (message-body). Метаинформации, содержащейся в HTTP заголовках ответа на запрос HEAD СЛЕДУЕТ быть идентичной информации, представляемой в ответ на запрос GET. Этот метод может использоваться для получения метаинформации об объекте запроса без непосредственной пересылки тела объекта (entity-body). Этот метод часто используется для тестирования гипертекстовых связей в целях проверки правильности, достижимости, и времени модификации.</p>
	<p>В ответе не получил код во вкладке Body(отсутсвует HTML код)
	</p>
	<h2>Task 6</h2>
	<ol>
		<li>www.instagram.com</li>
		<li>www.facebook.com</li>
		<li>www.google.com</li>
		<li>www.youtube.com</li>
		<li>github.com</li>
	</ol>
	<p>В більшості випадків, метод POSТ використовувався з метою заповнення форм для реєстрації, або відправлення feedback</p>
	<h2>Task 8</h2>
	<a href="http://chetverykanton.zzz.com.ua/index.html">Ссылка на хостнинг</a>
</body>

</html>